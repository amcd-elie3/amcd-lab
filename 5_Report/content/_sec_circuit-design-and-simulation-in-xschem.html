<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>sec_circuit-design-and-simulation-in-xschem</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/clipboard/clipboard.min.js"></script>
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/popper.min.js"></script>
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/anchor.min.js"></script>
<link href="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_sec_circuit-design-and-simulation-in-xschem_files/libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_sec_circuit-design-and-simulation-in-xschem_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_sec_circuit-design-and-simulation-in-xschem_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_sec_circuit-design-and-simulation-in-xschem_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="circuit-design-and-simulation-in-xschem" class="level1">
<h1>Circuit Design and Simulation in Xschem</h1>
<p>This section details the process of designing and simulating the second-order biquad filter using Xschem and ngspice. Our methodology progressed from an ideal, op-amp-based circuit to a more practical, transistor-level implementation, allowing for a comparative analysis of ideal and real-world performance.</p>
<section id="ideal-circuit-universal-active-filter" class="level2">
<h2 class="anchored" data-anchor-id="ideal-circuit-universal-active-filter">Ideal Circuit: Universal Active Filter</h2>
<p>Our initial approach was to implement a universal second-order biquad filter based on the topology described in Experiment 4 of the Texas Instruments ASLK Pro Manual. This architecture is valuable because it simultaneously provides low-pass (LPF), high-pass (HPF), band-pass (BPF), and band-stop (BSF) outputs from a single circuit.</p>
<section id="circuit-topology-and-theory" class="level3">
<h3 class="anchored" data-anchor-id="circuit-topology-and-theory">Circuit Topology and Theory</h3>
<p>The filter is based on the Tow-Thomas biquad topology, which uses two integrators and an inverter to realize the filter transfer functions. The general schematic is shown in <a href="#fig-ideal-uni" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="fig-ideal-uni" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ideal-uni-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ideal-biquad-uni.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ideal-uni-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Schematic of the ideal universal second-order active filter, based on the ASLK Pro manual.
</figcaption>
</figure>
</div>
</section>
<section id="ideal-op-amp-model-and-symbol-creation" class="level3">
<h3 class="anchored" data-anchor-id="ideal-op-amp-model-and-symbol-creation">Ideal Op-Amp Model and Symbol Creation</h3>
<p>To simulate the ideal behavior of this circuit, we first required an ideal operational amplifier model. We used a standard single-pole op-amp SPICE model from eCircuit Center, shown in <strong>?@lst-opamp-subckt</strong>.</p>
<p><strong>Implementation Note:</strong> A common pitfall during setup is the path configuration for custom models. Xschem initially searches for model files in the project’s home directory. We had to configure the simulation settings to ensure Xschem could locate the <code>OPAMP1.cir</code> file in our circuit’s working directory.</p>
</section>
<section id="simulation-and-results" class="level3">
<h3 class="anchored" data-anchor-id="simulation-and-results">Simulation and Results</h3>
<p>With the ideal op-amp symbol and model in place, we constructed the schematic for the universal biquad filter. We then wrote an ngspice script (<strong>?@lst-ideal-uni-sim</strong>) to perform the analysis.</p>
</section>
<section id="frequency-response-analysis---magnitude-response" class="level3">
<h3 class="anchored" data-anchor-id="frequency-response-analysis---magnitude-response">Frequency Response Analysis - Magnitude Response</h3>
<p>The magnitude response of the system was plotted to observe how the system amplifies or attenuates input signals across different frequencies. The Bode magnitude plot gives a clear insight into the bandwidth and gain characteristics.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mag_resp.png" class="img-fluid figure-img"></p>
<figcaption>Magnitude Response</figcaption>
</figure>
</div>
</section>
<section id="phase-response" class="level3">
<h3 class="anchored" data-anchor-id="phase-response">Phase Response</h3>
<p>The phase response of the system was analyzed to study the phase shift introduced at various frequencies. This is essential for understanding the signal integrity and phase margin.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/phase_resp.png" class="img-fluid figure-img"></p>
<figcaption>Phase Response</figcaption>
</figure>
</div>
</section>
<section id="transient-analysis" class="level3">
<h3 class="anchored" data-anchor-id="transient-analysis">Transient Analysis</h3>
<p>Transient analysis was performed to examine how the system responds to a time-domain input.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/transient_response_ideal.png" class="img-fluid figure-img"></p>
<figcaption>Transient Response</figcaption>
</figure>
</div>
<p>The plot clearly shows the expected behavior for each filter type, centered around 1 kHz. The BPF peaks at the center frequency, while the BSF shows a notch at the same point.</p>
</section>
</section>
<section id="real-circuit-gm-c-biquad-filter" class="level2">
<h2 class="anchored" data-anchor-id="real-circuit-gm-c-biquad-filter">Real Circuit: Gm-C Biquad Filter</h2>
<p>This section details the transition from an ideal circuit simulation to a practical, transistor-level implementation. The core of this process is replacing the ideal op-amp model with a custom-designed Operational Transconductance Amplifier (OTA) within the IHP Microelectronics SG13G2 130nm CMOS technology.</p>
<section id="initial-approach-the-5-transistor-ota" class="level3">
<h3 class="anchored" data-anchor-id="initial-approach-the-5-transistor-ota">Initial Approach: The 5-Transistor OTA</h3>
<p>Our first step towards a real circuit was to design and size a fundamental analog building block: the 5-Transistor (5T) OTA.</p>
<section id="from-an-ideal-model-to-a-transistor-level-circuit" class="level4">
<h4 class="anchored" data-anchor-id="from-an-ideal-model-to-a-transistor-level-circuit">From an Ideal Model to a Transistor-Level Circuit</h4>
<p>In the initial phase of the project, we used an ideal op-amp, which is a behavioral model in SPICE. It assumes infinite gain, infinite bandwidth, and zero output impedance. This is useful for verifying circuit topology and transfer functions at a conceptual level.</p>
<p>A real OTA, however, is built from transistors and has inherent physical limitations: * <strong>Finite Gain and Bandwidth</strong>: The voltage gain is limited by the transistor’s output impedance and transconductance. * <strong>Power Consumption</strong>: It draws a finite DC current from the power supply. * <strong>Non-linearities</strong>: Its behavior can deviate from the ideal linear model, especially with large input signals. * <strong>Noise</strong>: The transistors introduce electronic noise into the circuit.</p>
<p>Transitioning to a transistor-level OTA is therefore essential for designing a circuit that can be physically manufactured and will perform predictably.</p>
</section>
<section id="anatomy-of-a-5t-ota" class="level4">
<h4 class="anchored" data-anchor-id="anatomy-of-a-5t-ota">Anatomy of a 5T OTA</h4>
<p>The 5T OTA is a cornerstone of analog design due to its simplicity and efficiency. It consists of a differential input pair (M1, M2), a current-mirror active load (M3, M4), and a tail current source (M5) which sets the amplifier’s bias point.</p>
<div id="fig-Basic-5T-OTA-Schematic" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Basic-5T-OTA-Schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/basic-5T-OTA.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Basic-5T-OTA-Schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Basic 5T OTA Schematic
</figcaption>
</figure>
</div>
<p>In this circuit: - <strong>M1 and M2</strong> form the input differential pair. They operate in the saturation region, where the drain current is controlled by the gate-source voltage (<span class="math inline">\(V_{GS}\)</span>). The differential input voltage (<span class="math inline">\(V_{in,p} - V_{in,n}\)</span>) creates a differential current between the two branches. - <strong>M3 and M4</strong> form a PMOS current mirror that acts as the active load. This configuration provides a high output impedance, which helps achieve a higher voltage gain compared to a simple resistive load. - <strong>M5</strong> is the tail current source, which provides a constant bias current (<span class="math inline">\(I_{tail}\)</span>) to the differential pair. This current is mirrored from a reference current source via M6.</p>
<p>The transconductance (<span class="math inline">\(g_m\)</span>) of the OTA is primarily set by the characteristics of the input pair and its bias current.</p>
</section>
<section id="sizing-the-5t-ota-with-the-gmid-methodology" class="level4">
<h4 class="anchored" data-anchor-id="sizing-the-5t-ota-with-the-gmid-methodology">Sizing the 5T OTA with the <code>gm/ID</code> Methodology</h4>
<p>To determine the transistor dimensions (W/L), we used the modern <code>gm/ID</code> sizing methodology. This approach utilizes pre-characterized lookup tables from foundry data (in our case, SG13G2) to achieve an optimal balance between performance metrics like gain, speed, and power.</p>
<p>The quantitative sizing process is summarized below.</p>
<p><strong>Design Specifications &amp; Key Parameters</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 25%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Technology</td>
<td>SG13G2 130nm</td>
<td>IHP Microelectronics CMOS process</td>
</tr>
<tr class="even">
<td>Load Capacitance</td>
<td>50 fF</td>
<td>Assumed load for bandwidth calculation</td>
</tr>
<tr class="odd">
<td>Target Bandwidth</td>
<td>10 MHz</td>
<td>-3dB bandwidth target for the OTA</td>
</tr>
<tr class="even">
<td>Total Current Limit</td>
<td>10 µA</td>
<td>Maximum allowed supply current</td>
</tr>
<tr class="odd">
<td>PMOS <code>gm/ID</code> (M3, M4)</td>
<td>5 S/A</td>
<td>Operating point for the active load</td>
</tr>
<tr class="even">
<td>NMOS <code>gm/ID</code> (M1, M2)</td>
<td>10 S/A</td>
<td>Operating point for the differential pair</td>
</tr>
<tr class="odd">
<td>Channel Length (L)</td>
<td>5 µm</td>
<td>Chosen for high intrinsic gain (<code>gm/gds</code>)</td>
</tr>
</tbody>
</table>
<p><strong>Quantitative Sizing Analysis</strong></p>
<ol type="1">
<li><p><strong>Required Transconductance (<span class="math inline">\(g_m\)</span>)</strong>: The target bandwidth (<span class="math inline">\(f_{bw}\)</span>) for a given load (<span class="math inline">\(C_{load}\)</span>) dictates the required transconductance of the input pair. We include a margin of 3x to account for parasitics. <span class="math display">\[ g_{m1,2} = f_{bw} \times 3 \times 4\pi C_{load} = 10 \text{ MHz} \times 3 \times 4\pi \times 50 \text{ fF} \approx 18.8 \text{ µS} \]</span></p></li>
<li><p><strong>Bias Current Calculation</strong>: With a target <code>gm/ID</code> of 10 S/A for the input pair, the required drain current per transistor is: <span class="math display">\[ I_{D1,2} = \frac{g_{m1,2}}{g_m/I_D} = \frac{18.8 \text{ µS}}{10 \text{ S/A}} = 1.88 \text{ µA} \]</span> The total tail current is <span class="math inline">\(I_{tail} = 2 \times I_{D1,2} = 3.76 \text{ µA}\)</span>, which was rounded up to <strong>4.0 µA</strong>. This meets our power consumption target of &lt; 10 µA.</p></li>
<li><p><strong>DC Gain (<span class="math inline">\(A_0\)</span>) Calculation</strong>: The DC voltage gain is the transconductance divided by the total output conductance (<span class="math inline">\(g_{ds1,2} + g_{ds3,4}\)</span>). Using the lookup tables to find the intrinsic gain (<code>gm/gds</code>) for our chosen operating points and <code>L=5µm</code>: <span class="math display">\[ A_0 = \frac{g_{m1,2}}{g_{ds1,2} + g_{ds3,4}} \Rightarrow 20 \log_{10}(A_0) \approx 34.8 \text{ dB} \]</span></p></li>
<li><p><strong>Transistor Widths (W)</strong>: The final step is to find the transistor widths that provide the required currents for the chosen <code>gm/ID</code> and <code>L</code>. This is done by looking up the current density (<code>ID/W</code>) and calculating <span class="math inline">\(W = I_D / (I_D/W)\)</span>.</p></li>
</ol>
<p>Based on this quantitative sizing, the following schematic was created in Xschem, representing the physical implementation of our basic 5T OTA.</p>
<div id="fig-Basic-5T-OTA-Xschem" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Basic-5T-OTA-Xschem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/basic-5T-OTA-xschem.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Basic-5T-OTA-Xschem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Xschem implementation of the sized 5T OTA
</figcaption>
</figure>
</div>
</section>
</section>
<section id="implementation-with-the-universal-biquad-filter" class="level3">
<h3 class="anchored" data-anchor-id="implementation-with-the-universal-biquad-filter">Implementation with the Universal Biquad Filter</h3>
<p>With a basic OTA designed, we moved to implement a filter. For this, we used an initial 5T OTA design from Professor Pretl’s documentation as a reference, primarily because it included additional biasing circuitry for enable/disable functionality. For this implementation, a bias current (<code>I_bias</code>) of <strong>20µA</strong> was used.</p>
<p>The schematic below shows this specific OTA. In addition to the core 5T structure (M1-M5), it includes transistors (M7, M8, M12, M13) controlled by enable signals (<code>ena</code>, <code>d_ena</code>) that can shut down the bias currents to turn the OTA off.</p>
<div id="fig-Pretl-OTA" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Pretl-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ota-5t-pretl.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Pretl-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Xschem schematic of the 5T OTA used in the filter.
</figcaption>
</figure>
</div>
<p>We then replaced the ideal op-amp blocks in our universal biquad filter with this real, transistor-level OTA. This is a critical step: while the ideal circuit verifies the mathematical correctness of the filter topology, the real circuit tests whether the design can function with the physical limitations (finite gain, low drive current) of the chosen OTA.</p>
<div id="fig-Universal-Biquad" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Universal-Biquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/real-biquad-uni.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Universal-Biquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Xschem schematic of the Universal Biquad Filter using the real 5T OTA.
</figcaption>
</figure>
</div>
<section id="simulation-and-analysis-of-failure" class="level4">
<h4 class="anchored" data-anchor-id="simulation-and-analysis-of-failure">Simulation and Analysis of Failure</h4>
<p>The AC analysis of the real-circuit universal biquad produced the following results, which represent a complete failure of the filter.</p>
<div id="fig-Universal-Biquad-Output" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Universal-Biquad-Output-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/real-biquad-uni-output.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Universal-Biquad-Output-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: AC simulation results for the Universal Biquad Filter.
</figcaption>
</figure>
</div>
<p>The results unequivocally show that the circuit is not performing any filtering. This failure is a direct consequence of the OTA’s poor performance, particularly its low DC gain (~35 dB) and insufficient drive current, which are unable to make the integrator loops in the biquad operate correctly.</p>
</section>
</section>
<section id="design-challenges-and-pivot" class="level3">
<h3 class="anchored" data-anchor-id="design-challenges-and-pivot">Design Challenges and Pivot</h3>
<p>The unsuccessful simulation of the universal biquad filter highlighted critical flaws in our initial approach:</p>
<ol type="1">
<li><strong>Topology Unsuitability</strong>: The universal biquad topology, while versatile in theory, proved overly complex and sensitive for a practical IC implementation with a simple OTA.</li>
<li><strong>OTA Performance Limitations</strong>: The quantitative analysis and simulation results confirmed that the 5T OTA was the primary bottleneck. The DC gain was insufficient for a high-Q filter, and the drive current was too low.</li>
</ol>
<p>These findings necessitated a complete redesign of both the filter topology and the core amplifier.</p>
</section>
<section id="a-new-direction-bakers-gm-c-biquad-filter" class="level3">
<h3 class="anchored" data-anchor-id="a-new-direction-bakers-gm-c-biquad-filter">A New Direction: Baker’s Gm-C Biquad Filter</h3>
<p>We pivoted to a more robust design by referencing R. Jacob Baker’s <em>CMOS Mixed-Signal Circuit Design</em>. We selected a <strong>Gm-C biquad filter</strong> topology and set out to design a high-performance, fully differential OTA to drive it.</p>
<section id="high-performance-fully-differential-ota-conceptual-architecture" class="level4">
<h4 class="anchored" data-anchor-id="high-performance-fully-differential-ota-conceptual-architecture">High-Performance Fully Differential OTA: Conceptual Architecture</h4>
<p>The chosen architecture is a fully differential OTA designed to convert a differential input voltage into a differential output current. It is composed of three main functional blocks.</p>
<div id="fig-Baker-OTA" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Baker-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ota-baker-book.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Baker-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Conceptual schematic of the fully differential OTA from Baker.
</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Main Amplifier Stage</strong>: The core is a single-stage differential amplifier. Transistors <strong>M1</strong> and <strong>M2</strong> form the NMOS input differential pair. <strong>M7</strong> and <strong>M8</strong> are PMOS transistors acting as an active load, sourcing current into the output nodes (<code>vout+</code>, <code>vout-</code>) and providing high output resistance for gain. <strong>M11</strong> is a tail current source that sets the DC bias for the input pair.</p></li>
<li><p><strong>Biasing Circuit</strong>: The section on the left, with the <strong>Tuning Current</strong> source and diode-connected transistors <strong>M9</strong> and <strong>M10</strong>, is the master biasing circuit. The external tuning current establishes stable gate-to-source voltages that are then used to bias the gates of <strong>M11</strong> and <strong>M12</strong> via current mirroring.</p></li>
<li><p><strong>Common-Mode Feedback (CMFB) Circuit</strong>: In a fully differential amplifier, the DC level of the outputs must be precisely defined. The CMFB circuit (<strong>M3-M6</strong>, <strong>M12</strong>) senses the common-mode voltage of the outputs, compares it to a reference voltage (<strong>VCM</strong>), and creates a negative feedback loop by adjusting the gate voltage of the active load transistors (<strong>M7, M8</strong>). This locks the output common-mode voltage at a stable, desired level.</p></li>
</ul>
</section>
<section id="sizing-the-high-performance-ota" class="level4">
<h4 class="anchored" data-anchor-id="sizing-the-high-performance-ota">Sizing the High-Performance OTA</h4>
<p>We adapted the <code>gm/ID</code> methodology to size this more complex OTA. The design goals for this amplifier were significantly more ambitious than for the initial 5T OTA, targeting higher gain and drive current suitable for a high-performance filter.</p>
<p><strong>New Design Specifications</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 27%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Value</th>
<th>Comparison with 5T OTA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Target DC Gain</td>
<td>60 dB</td>
<td>Much higher than the 35 dB achieved</td>
</tr>
<tr class="even">
<td>Input Bias Current</td>
<td>100 µA</td>
<td>A 5x increase over the 20µA used</td>
</tr>
<tr class="odd">
<td><code>gm/ID</code> (Input Pair)</td>
<td>18 S/A</td>
<td>Higher efficiency (weaker inversion)</td>
</tr>
<tr class="even">
<td>Channel Length (L)</td>
<td>0.5 µm</td>
<td>Shorter, for higher speed</td>
</tr>
</tbody>
</table>
<p><strong>Quantitative Sizing Analysis</strong></p>
<p>The sizing began with the bandwidth requirement, which sets the needed transconductance. <span class="math display">\[ g_{m1,2} = f_{bw} \times 2\pi C_{load} \times (\text{Safety Factor}) = 10\text{e}6 \times 2\pi \times 50\text{e-15} \times 3 \approx 10 \text{ µS} \]</span> From this, the bias currents for the differential pair and the tail current were calculated: <span class="math display">\[ I_{D1,2} = \frac{g_{m1,2}}{g_m/I_D} = \frac{10 \text{ µS}}{18 \text{ S/A}} \approx 0.52 \text{ µA} \]</span> <span class="math display">\[ I_{tail} = 2 \times I_{D1,2} \approx 1.05 \text{ µA} \]</span></p>
<p>The crucial step was the DC gain calculation. The gain is set by the input transconductance and the total output resistance (<span class="math inline">\(r_{o,total} = r_{o,nmos} || r_{o,pmos}\)</span>). <span class="math display">\[ A_0 = g_{m1,2} \times (r_{o,1,2} || r_{o,7,8}) \]</span> Using lookup tables to find the intrinsic gain (<code>gm/gds</code>) for each transistor at <code>L=0.5µm</code> and then calculating the output resistances, the analysis yielded a very low result: <span class="math display">\[ A_0 \Rightarrow 20 \log_{10}(A_0) \approx 21.5 \text{ dB} \]</span></p>
<p><strong>Analysis of Sizing Limitations</strong></p>
<p>The sizing exercise exposed critical design trade-offs and challenges: 1. <strong>Failure to Meet Gain Target</strong>: The resulting <strong>21.5 dB</strong> of gain falls drastically short of the <strong>60 dB</strong> specification. This is a direct consequence of using a short channel length (<code>L=0.5µm</code>), which severely limits the transistor’s intrinsic gain (<code>gm/gds</code>), making high DC gain unachievable. 2. <strong>Headroom and Output Swing Failure</strong>: The voltage headroom analysis revealed that the design could not support the required output voltage levels, stating explicitly: <code>[WARNING] Output voltage requirement is NOT met!</code>.</p>
<p>Despite attempts to rectify this by exploring different <code>gm/ID</code> ratios and longer channel lengths, the 60 dB target remained elusive within the constraints of this specific topology and sizing choices. Faced with these results, we proceeded by implementing the OTA in Xschem using the values calculated from our analysis, acknowledging the known performance limitations.</p>
<div id="fig-Gm-100u-OTA" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Gm-100u-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/real-ota_gm_100u.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Gm-100u-OTA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Xschem schematic of the sized high-performance OTA.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="component-sizing-and-filter-design" class="level3">
<h3 class="anchored" data-anchor-id="component-sizing-and-filter-design">Component Sizing and Filter Design</h3>
<p>Despite the OTA’s lower-than-desired gain, we proceeded to design the filter’s passive network. The chosen topology is a Gm-C biquadratic filter, a versatile and tunable second-order architecture that uses integrators made from transconductors and capacitors.</p>
<div id="fig-Final-Filter-Topology" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Final-Filter-Topology-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/biquad-filter-ota-baker-book.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Final-Filter-Topology-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Schematic of the Gm-C Biquad Filter Topology
</figcaption>
</figure>
</div>
<p>This Gm-C biquad structure is essentially a cascade of two integrator blocks with feedback. The first stage (built around gm1, gm2, and associated capacitors) and the second stage (built around gm3, gm4, and capacitors) are interconnected. The feedback from the final output back to the input creates the second-order response necessary for achieving high Q-factors. A primary advantage of this topology is its <strong>electronic tunability</strong>; the filter’s center frequency (<span class="math inline">\(f_0\)</span>) and quality factor (Q) are set by gm and C values. Since the gm can be adjusted by changing bias currents, the filter can be tuned after fabrication, making it ideal for integrated circuits where precise resistor values are difficult to achieve.</p>
<section id="design-calculations" class="level4">
<h4 class="anchored" data-anchor-id="design-calculations">Design Calculations</h4>
<p>The design process involves mapping the desired filter characteristics onto the general biquad transfer function and then solving for the specific capacitance values.</p>
<p><strong>1. Define Target Specifications</strong> * <strong>Filter Type</strong>: Low-Pass Filter * <strong>Center/Cutoff Frequency (<span class="math inline">\(f_0\)</span>)</strong>: 1 kHz * <strong>Quality Factor (Q)</strong>: 10 * <strong>Transconductance (<span class="math inline">\(g_m\)</span>)</strong>: 100 µS (for all transconductors, gm1 through gm4)</p>
<p><strong>2. Simplify the Topology for a Low-Pass Filter</strong> A standard second-order low-pass filter has a transfer function of the form <span class="math inline">\(H(s) = a_0 / (s^2 + s(\omega_0/Q) + \omega_0^2)\)</span>. To achieve this, the numerator terms with ‘s’ and ‘s²’ must be zero. In the generalized topology, these terms are controlled by capacitors <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_3\)</span>. To eliminate them, we must set their values to zero: * <span class="math inline">\(C_1 = 0\)</span> * <span class="math inline">\(C_3 = 0\)</span> This physically means removing these two capacitors from the schematic, simplifying the design significantly.</p>
<p><strong>3. Use the Simplified Design Equations</strong> With <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_3\)</span> removed, the design equations for the filter’s characteristics simplify to: <span class="math display">\[ (2\pi f_0)^2 = \frac{g_{m1}}{C_2} \frac{g_{m3}}{C_4} \frac{g_{m4}}{g_{m3}} \]</span> <span class="math display">\[ \frac{2\pi f_0}{Q} = \frac{g_{m1}}{C_2} \frac{g_{m2}}{g_{m1}} \]</span></p>
<p><strong>4. Solve for the Capacitors</strong> First, we calculate the angular frequency <span class="math inline">\(\omega_0 = 2\pi f_0\)</span>: <span class="math display">\[ \omega_0 = 2 \pi \times 1000 \text{ Hz} = 6283.2 \text{ rad/s} \]</span></p>
<p>Next, we solve the equation for the Q-factor to find <span class="math inline">\(C_2\)</span>. The equation simplifies nicely: <span class="math display">\[ \frac{\omega_0}{Q} = \frac{g_{m2}}{C_2} \]</span> <span class="math display">\[ C_2 = \frac{g_{m2} \times Q}{\omega_0} = \frac{100 \times 10^{-6} \text{ S} \times 10}{6283.2 \text{ rad/s}} = 1.5915 \times 10^{-7} \text{ F} \]</span> <span class="math display">\[ \mathbf{C_2 = 159.2 \text{ nF}} \]</span></p>
<p>Now, we solve the equation for the center frequency to find <span class="math inline">\(C_4\)</span>. The equation simplifies to: <span class="math display">\[ (\omega_0)^2 = \frac{g_{m1}}{C_2} \frac{g_{m4}}{C_4} \]</span> We can substitute the term <span class="math inline">\(\frac{g_{m1}}{C_2}\)</span> with <span class="math inline">\(\frac{\omega_0}{Q}\)</span> (since <span class="math inline">\(g_{m1}=g_{m2}\)</span>): <span class="math display">\[ (\omega_0)^2 = \frac{\omega_0}{Q} \frac{g_{m4}}{C_4} \implies \omega_0 Q = \frac{g_{m4}}{C_4} \]</span> <span class="math display">\[ C_4 = \frac{g_{m4}}{\omega_0 Q} = \frac{100 \times 10^{-6} \text{ S}}{6283.2 \text{ rad/s} \times 10} = 1.5915 \times 10^{-9} \text{ F} \]</span> <span class="math display">\[ \mathbf{C_4 = 1.59 \text{ nF}} \]</span></p>
<p><strong>Final Design Values</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Component</th>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(C_1\)</span></td>
<td style="text-align: left;">0 (removed)</td>
<td style="text-align: left;">Simplifies filter to low-pass response</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(C_2\)</span></td>
<td style="text-align: left;">159.2 nF</td>
<td style="text-align: left;">Sets the Q-factor</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(C_3\)</span></td>
<td style="text-align: left;">0 (removed)</td>
<td style="text-align: left;">Simplifies filter to low-pass response</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(C_4\)</span></td>
<td style="text-align: left;">1.59 nF</td>
<td style="text-align: left;">Sets the center frequency, <span class="math inline">\(f_0\)</span></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="final-implementation-and-verification" class="level3">
<h3 class="anchored" data-anchor-id="final-implementation-and-verification">Final Implementation and Verification</h3>
<p>The final Gm-C biquad filter was assembled in Xschem using the newly designed OTAs and calculated capacitors.</p>
<div id="fig-Final-Biquad" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Final-Biquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/real-biquad_gm_c.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Final-Biquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Final Xschem schematic of the Gm-C biquad filter.
</figcaption>
</figure>
</div>
<p>AC analysis was performed, with the expected output being a low-pass response with a sharp resonant peak at 1 kHz due to the high Q-factor, followed by a -40 dB/decade roll-off.</p>
<div id="fig-Final-Bode" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Final-Bode-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/real-biquad_gm_c-output.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Final-Bode-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: Simulated Bode plot of the final low-pass filter.
</figcaption>
</figure>
</div>
<p>The simulation confirms the filter is operating as designed. The success of the final filter, even with a sub-optimal OTA, demonstrates the robustness of the Gm-C biquad topology. It suggests that while higher OTA gain would improve performance (e.g., Q-factor accuracy), the fundamental design is sound.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>